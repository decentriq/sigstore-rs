/*
 * Rekor
 *
 * Rekor is a cryptographically secure, immutable transparency log for signed software releases.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::crypto::merkle::hex_to_hash_output;
use crate::crypto::CosignVerificationKey;
use crate::errors::SigstoreError;
use crate::rekor::models::checkpoint::Checkpoint;
use crate::rekor::models::ConsistencyProof;
use crate::rekor::TreeSize;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct LogInfo {
    /// The current hash value stored at the root of the merkle tree
    #[serde(rename = "rootHash")]
    pub root_hash: String,
    /// The current number of nodes in the merkle tree
    #[serde(rename = "treeSize")]
    pub tree_size: TreeSize,
    /// The current signed tree head
    #[serde(rename = "signedTreeHead")]
    pub signed_tree_head: Checkpoint,
    /// The current treeID
    #[serde(rename = "treeID")]
    pub tree_id: Option<String>,
    #[serde(rename = "inactiveShards", skip_serializing_if = "Option::is_none")]
    pub inactive_shards: Option<Vec<crate::rekor::models::InactiveShardLogInfo>>,
}

impl LogInfo {
    pub fn new(root_hash: String, tree_size: TreeSize, signed_tree_head: Checkpoint) -> LogInfo {
        LogInfo {
            root_hash,
            tree_size,
            signed_tree_head,
            tree_id: None,
            inactive_shards: None,
        }
    }
    /// Verify the consistency of the proof provided by the log.
    ///
    /// Example:
    /// ```rust
    /// use sigstore::crypto::{CosignVerificationKey, SigningScheme};
    /// use sigstore::rekor::apis::configuration::Configuration;
    /// use sigstore::rekor::apis::pubkey_api::get_public_key;
    /// use sigstore::rekor::apis::tlog_api::{get_log_info, get_log_proof};
    ///
    /// #[tokio::main]
    /// async fn main() {
    ///     let rekor_config = Configuration::default();
    ///
    ///     // Important: in practice obtain the rekor key via TUF repo or another secure channel!
    ///     let rekor_key = get_public_key(&rekor_config, None)
    ///         .await
    ///         .expect("failed to fetch pubkey from remote log");
    ///     let rekor_key =  CosignVerificationKey::from_pem(
    ///         rekor_key.as_bytes(),
    ///         &SigningScheme::ECDSA_P256_SHA256_ASN1,
    ///     ).expect("failed to parse rekor key");
    ///     // fetch log info twice and run consistency proof
    ///     let log_info1 = get_log_info(&rekor_config)
    ///         .await
    ///         .expect("failed to fetch data from remote");
    ///     let log_info2 = get_log_info(&rekor_config)
    ///         .await
    ///         .expect("failed to fetch data from remote");
    ///
    ///      // get a proof using log_info1 as the previous tree state
    ///      let proof = get_log_proof(
    ///         &rekor_config,
    ///         log_info2.tree_size as _,
    ///         Some(&log_info1.tree_size.to_string()),
    ///         None,
    ///     )
    ///     .await.expect("failed to fetch data from remote");
    ///      log_info2
    ///         .verify_consistency(log_info1.tree_size as usize, &log_info1.root_hash, &proof, &rekor_key)
    ///         .expect("failed to verify log consistency");
    /// }
    ///
    /// ```
    pub fn verify_consistency(
        &self,
        old_size: usize,
        old_root: &str,
        consistency_proof: &ConsistencyProof,
        rekor_key: &CosignVerificationKey,
    ) -> Result<(), SigstoreError> {
        // verify checkpoint is signed by log
        self.signed_tree_head.verify_signature(rekor_key)?;

        self.signed_tree_head
            .is_valid_for_proof(&hex_to_hash_output(&self.root_hash)?, self.tree_size as u64)?;
        consistency_proof.verify(old_size, old_root, self.tree_size as _)?;
        Ok(())
    }
}
